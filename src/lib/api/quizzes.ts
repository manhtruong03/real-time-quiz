// src/lib/api/quizzes.ts
import type { QuizDTO, Page } from "@/src/lib/types/api";
import { fetchWithAuth, FetchOptions } from "./client";

const API_BASE_URL =
  process.env.NEXT_PUBLIC_API_BASE_URL || "http://localhost:8080";

// Interface for pagination parameters (keep existing functions if they are there)
interface PageableParams {
  page?: number;
  size?: number;
  sort?: string;
}

// --- KEEP existing fetchMyQuizzes, fetchPublicQuizzes, fetchQuizDetails ---
// ... (previous functions like fetchMyQuizzes, fetchPublicQuizzes, fetchQuizDetails) ...
export async function fetchMyQuizzes(
  params?: PageableParams
): Promise<Page<QuizDTO>> {
  const queryParams = new URLSearchParams();
  if (params?.page !== undefined) queryParams.set("page", String(params.page));
  if (params?.size !== undefined) queryParams.set("size", String(params.size));
  if (params?.sort) queryParams.set("sort", params.sort);

  const endpoint = `${API_BASE_URL}/api/quizzes/my-quizzes?${queryParams.toString()}`;
  console.log(`[API Quizzes] Fetching my quizzes from ${endpoint}`);

  const options: FetchOptions = {
    method: "GET",
    includeAuthHeader: true, // This endpoint requires authentication
  };
  return fetchWithAuth<Page<QuizDTO>>(endpoint, options);
}

export async function fetchPublicQuizzes(
  params?: PageableParams
): Promise<Page<QuizDTO>> {
  const queryParams = new URLSearchParams();
  if (params?.page !== undefined) queryParams.set("page", String(params.page));
  if (params?.size !== undefined) queryParams.set("size", String(params.size));
  if (params?.sort) queryParams.set("sort", params.sort);

  const endpoint = `${API_BASE_URL}/api/quizzes/public?${queryParams.toString()}`;
  console.log(`[API Quizzes] Fetching public quizzes from ${endpoint}`);

  const options: FetchOptions = {
    method: "GET",
    includeAuthHeader: false, // Public endpoint might not need auth
  };
  return fetchWithAuth<Page<QuizDTO>>(endpoint, options);
}

export async function fetchQuizDetails(quizId: string): Promise<QuizDTO> {
  if (!quizId) {
    throw new Error("Quiz ID is required to fetch details.");
  }
  const endpoint = `${API_BASE_URL}/api/quizzes/${quizId}`;
  console.log(`[API Quizzes] Fetching quiz details from ${endpoint}`);
  const options: FetchOptions = {
    method: "GET",
    includeAuthHeader: true, // Assuming auth needed
  };
  return fetchWithAuth<QuizDTO>(endpoint, options);
}

/**
 * Creates a new quiz via the backend API.
 * @param quizData - The QuizDTO object representing the quiz to create.
 * @returns A promise that resolves with the created QuizDTO (as returned by the backend).
 * @throws {AuthApiError} If the request fails.
 */
export async function createQuiz(quizData: QuizDTO): Promise<QuizDTO> {
  const endpoint = `${API_BASE_URL}/api/quizzes`;
  console.log(`[API Quizzes] Creating new quiz at ${endpoint}`);

  const options: FetchOptions = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(quizData),
    includeAuthHeader: true, // Creating a quiz requires authentication
  };

  try {
    // The backend should return the created QuizDTO with its new UUID etc.
    const createdQuiz = await fetchWithAuth<QuizDTO>(endpoint, options);
    console.log(
      `[API Quizzes] Quiz created successfully (UUID: ${createdQuiz.uuid})`
    );
    return createdQuiz;
  } catch (error) {
    console.error("[API Quizzes] Failed to create quiz:", error);
    // Re-throw the error so the caller can handle it (e.g., show toast)
    throw error;
  }
}

/**
 * Updates an existing quiz via the backend API.
 * @param quizId - The UUID of the quiz to update.
 * @param quizData - The QuizDTO object containing the updated quiz data.
 * @returns A promise that resolves with the updated QuizDTO (as returned by the backend).
 * @throws {AuthApiError} If the request fails.
 */
export async function updateQuiz(
  quizId: string,
  quizData: QuizDTO
): Promise<QuizDTO> {
  // Note: OpenAPI spec doesn't explicitly define PUT /api/quizzes/{quizId}
  // Assuming it exists and behaves similarly to POST but targets a specific ID.
  // Adjust endpoint and method if your backend implementation differs.
  if (!quizId) {
    throw new Error("Quiz ID is required for update.");
  }
  const endpoint = `${API_BASE_URL}/api/quizzes/${quizId}`; // Assuming PUT uses ID in path
  console.log(`[API Quizzes] Updating quiz ${quizId} at ${endpoint}`);

  // Remove fields that shouldn't be sent on update or are generated by backend
  const updatePayload: Partial<QuizDTO> = { ...quizData };
  delete updatePayload.uuid;
  delete updatePayload.creator;
  delete updatePayload.creator_username;
  delete updatePayload.created;
  delete updatePayload.modified;
  // Potentially remove question IDs if backend handles updates based on position/content match

  const options: FetchOptions = {
    method: "PUT", // Assuming PUT for update
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(updatePayload),
    includeAuthHeader: true, // Updating likely requires authentication
  };

  try {
    // Assuming backend returns the updated QuizDTO
    const updatedQuiz = await fetchWithAuth<QuizDTO>(endpoint, options);
    console.log(`[API Quizzes] Quiz ${quizId} updated successfully`);
    return updatedQuiz;
  } catch (error) {
    console.error(`[API Quizzes] Failed to update quiz ${quizId}:`, error);
    throw error; // Re-throw for caller handling
  }
}

// Optional: Add deleteQuiz function if needed
// export async function deleteQuiz(quizId: string): Promise<void> { ... }
